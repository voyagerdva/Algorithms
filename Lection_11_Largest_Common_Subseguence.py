# ==================================================
#
#   Lection 11.
#   поиск наибольшей общей подпоследовательности среди двух списков.
#
#   asymptotics: O(N*M)
#
# ==================================================

""" 
поиск в двумерном массиве последовательностей элементов, общих для каждой части (где части - от 0 до i, и от 0 до j) исходных числовых последовательностей,
с суммированием в каждой клетке массива количества общих элементов для текущей позиции, на основании значений в предыдущих клетках
"""
def lcs(A, B):
    """ 
    второстепенная часть. Подготовка массива длин и запуск циклов по строками и столбцам
    """
    F = [[0] * (len(B)+1) for i in range(len(A)+1)]

    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            """ 
            основная часть. Суммирование значения из предыдущего элемента с единицей при нахождении общего элемента,
            либо выбор максимального значения из предыдущих, если текущие элементы списков не равны.
            """
            if A[i-1] == B[j-1]:
                F[i][j] = F[i-1][j-1] + 1
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])

    return F, F[-1][-1]

A = [1, 3, 2, 4]
B = [5, 1, 2]

# A = [1, 4, 2, 3, 6, 5, 8, 9, 10]
# B = [1, 2, 4, 5, 6, 7, 8]


print(*lcs(A, B)[0], lcs(A, B)[1], sep='\n')